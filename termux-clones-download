#!/usr/bin/env bash
# executor_downloader.sh
# Interactive menu wrapper around a one-shot APK downloader/installer
# - Shows status per-APK (Pending, Downloading, Downloaded, Installed, Failed)
# - Default list: Codex.0..Codex.8 (same as original)
# - Logs to ~/.local/share/executor-downloader/run.log
# - Designed to be readable and safe for Termux / standard Android shells

set -euo pipefail
IFS=$'\n\t'

# ---------------- Configuration ----------------
BASE_URL="https://github.com/Fizlyss/cloud-phone/releases/download/er"
APK_NAMES=( "Codex.0.apk" "Codex.1.apk" "Codex.2.apk" "Codex.3.apk" "Codex.4.apk" "Codex.5.apk" "Codex.6.apk" "Codex.7.apk" "Codex.8.apk" )

APP_NAME="executor-downloader"

# ---------------- Paths ----------------
LOG_DIR="$HOME/.local/share/${APP_NAME}"
APK_DIR="$HOME/apks"
TMP_DIR="$HOME/.tmp_${APP_NAME}"
STATE_DIR="$HOME/.${APP_NAME}_state"
LOG_FILE="$LOG_DIR/run.log"

mkdir -p "$LOG_DIR" "$APK_DIR" "$TMP_DIR" "$STATE_DIR"

# ---------------- Utilities ----------------
timestamp() { date -u +"%Y-%m-%dT%H:%M:%SZ"; }

log() {
  mkdir -p "$LOG_DIR"
  printf "[%s] %s\n" "$(timestamp)" "$*" | tee -a "$LOG_FILE"
}

die() {
  printf "[%s] FATAL: %s\n" "$(timestamp)" "$*" | tee -a "$LOG_FILE" >&2
  exit 1
}

http_fetch_to() {
  # $1 url, $2 dest
  local url="$1" dest="$2" tmp="${dest}.part"
  rm -f "$tmp"
  if curl -fsSL --retry 5 --retry-delay 2 --connect-timeout 20 -o "$tmp" "$url" 2>>"$LOG_FILE"; then
    mv -f "$tmp" "$dest"
    return 0
  else
    rm -f "$tmp"
    return 1
  fi
}

pm_install_apk() {
  local apk="$1"
  log "Attempting install: $apk"
  if /system/bin/pm install -r -d --user 0 "$apk" >>"$LOG_FILE" 2>&1; then
    return 0
  fi
  if command -v cmd >/dev/null 2>&1 && cmd package install -r "$apk" >>"$LOG_FILE" 2>&1; then
    return 0
  fi
  if /system/bin/pm install "$apk" >>"$LOG_FILE" 2>&1; then
    return 0
  fi
  return 1
}

# ---------------- Status bookkeeping ----------------
declare -A STATUS
declare -A DETAIL
for name in "${APK_NAMES[@]}"; do
  STATUS["$name"]="Pending"
  DETAIL["$name"]=""
done

render_table() {
  clear
  printf "%-3s %-28s %-12s %s\n" "#" "Package" "Status" "Detail"
  printf "%-3s %-28s %-12s %s\n" "--" "----------------------------" "------------" "---------------------------"
  local i=1
  for name in "${APK_NAMES[@]}"; do
    printf "%-3d %-28s %-12s %s\n" "$i" "$name" "${STATUS[$name]}" "${DETAIL[$name]}"
    i=$((i+1))
  done
  echo
}

# ---------------- Tasks ----------------
download_and_maybe_install() {
  local install_after_download=${1:-1} # 1 = install after download, 0 = just download
  local ok_count=0 total=${#APK_NAMES[@]}

  for name in "${APK_NAMES[@]}"; do
    local url="$BASE_URL/$name"
    local dest="$APK_DIR/$name"

    STATUS["$name"]="Downloading"
    DETAIL["$name"]="$url"
    render_table
    log "Fetching $name from $url"

    if http_fetch_to "$url" "$dest"; then
      STATUS["$name"]="Downloaded"
      DETAIL["$name"]="$dest"
      render_table
      log "Downloaded $name -> $dest"

      if [ "$install_after_download" -eq 1 ]; then
        STATUS["$name"]="Installing"
        render_table
        if pm_install_apk "$dest"; then
          STATUS["$name"]="Installed"
          DETAIL["$name"]="Installed and removed"
          rm -f "$dest" || true
          log "Installed $name successfully and deleted $dest"
          ok_count=$((ok_count+1))
        else
          STATUS["$name"]="InstallFailed"
          DETAIL["$name"]="$dest (left for inspection)"
          log "WARN: Failed to install $name (left at $dest for inspection)"
        fi
      fi
    else
      STATUS["$name"]="DownloadFailed"
      DETAIL["$name"]="Could not fetch"
      render_table
      log "WARN: Could not download $name (skipping)"
      rm -f "$dest" || true
    fi
  done

  log "APK task finished: $ok_count/$total installed"
  read -rp "Press ENTER to continue..." _
}

# ---------------- Menu ----------------
show_menu() {
  while true; do
    render_table
    cat <<-MENU
Choose an action:
 1) Start: Download & Install all (one-shot)
 2) Download only (no install)
 3) Show current status (refresh)
 4) Set custom base URL (current: $BASE_URL)
 5) Load custom APK list (space-separated or newline file)
 6) Toggle auto-escalate to root with tsu (disabled by default)
 7) Clear downloaded APKs
 8) Exit
MENU
    read -rp "Enter choice [1-8]: " choice
    case "$choice" in
      1) download_and_maybe_install 1 ;;
      2) download_and_maybe_install 0 ;;
      3) render_table ; read -rp "Press ENTER to continue..." _ ;;
      4)
        read -rp "New base URL: " newurl
        if [ -n "$newurl" ]; then BASE_URL="$newurl"; log "BASE_URL set to $BASE_URL"; fi ;;
      5)
        echo "Enter APK names separated by spaces (e.g. Foo.apk Bar.apk), or provide a path to a file containing one filename per line."
        read -rp "Input or file path: " apkinput
        if [ -f "$apkinput" ]; then
          mapfile -t newlist < "$apkinput"
        else
          # split on spaces
          read -r -a newlist <<< "$apkinput"
        fi
        if [ "${#newlist[@]}" -gt 0 ]; then
          APK_NAMES=("\${newlist[@]}")
          for name in "${APK_NAMES[@]}"; do
            STATUS["$name"]="Pending"
            DETAIL["$name"]=""
          done
          log "Loaded custom APK list: ${APK_NAMES[*]}"
        fi ;;
      6)
        echo "The script will not auto-escalate by default. To enable re-exec under tsu, uncomment code in the script or implement as needed." ;;
      7)
        rm -f "$APK_DIR"/* 2>/dev/null || true
        log "Cleared $APK_DIR"
        for k in "${!STATUS[@]}"; do STATUS["$k"]="Pending"; DETAIL["$k"]=""; done
        read -rp "Cleared downloaded APKs. Press ENTER to continue..." _ ;;
      8) log "User requested exit"; exit 0 ;;
      *) echo "Invalid choice"; sleep 1 ;;
    esac
  done
}

# ---------------- Entry ----------------
main() {
  echo "${APP_NAME} â€” interactive APK downloader/installer"
  echo "Logs: $LOG_FILE"
  show_menu
}

main "$@" 
