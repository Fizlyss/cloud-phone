#!/usr/bin/env bash
set -euo pipefail

# Configuration
BASE_URL="https://github.com/Fizlyss/cloud-phone/releases/download/er"
APK_NAMES=( "test" "e13123131" "Codex.0.apk" "Codex.1.apk" "Codex.2.apk" "Codex.3.apk" "Codex.4.apk" "Codex.5.apk" "Codex.6.apk" "Codex.7.apk")
APK_DIR="$HOME/apks"
LOG_DIR="$HOME/.local/share/executor_clones_download"
mkdir -p "$APK_DIR" "$LOG_DIR"
LOG_FILE="$LOG_DIR/installation-$(date +%Y%m%d-%H%M%S).log"

# Globals
declare -gA STATUS
declare -gA PROGRESS
declare -gA APK_FULL_URLS   # filename -> full URL mapping (populated when listing a release)

# Colors
RED="\033[1;31m"; GREEN="\033[1;32m"; YELLOW="\033[1;33m"
BLUE="\033[1;34m"; CYAN="\033[1;36m"; ORANGE="\033[1;38;5;208m"
BOLD="\033[1m"; DIM="\033[2m"; RESET="\033[0m"

# Helpers
log() {
    echo "[$(date +"%F %T")] $1" >> "$LOG_FILE"
    echo -e "$1"
}
clear_screen() { command -v clear >/dev/null 2>&1 && clear || true; }

# Safe exit: if script is sourced, return; otherwise exit
safe_exit() {
    if [[ "${BASH_SOURCE[0]}" != "${0}" ]]; then
        return 0
    else
        exit 0
    fi
}

print_banner() {
    echo -e "${CYAN}"
    echo -e "██╗░░░██╗███████╗██████╗░███╗░░██╗██╗██╗░░██╗"
    echo -e "██║░░░██║██╔════╝██╔══██╗████╗░██║██║╚██╗██╔╝"
    echo -e "╚██╗░██╔╝█████╗░░██████╔╝██╔██╗██║██║░╚███╔╝░"
    echo -e "░╚████╔╝░██╔══╝░░██╔══██╗██║╚████║██║░██╔██╗░"
    echo -e "░░╚██╔╝░░███████╗██║░░██║██║░╚███║██║██╔╝╚██╗"
    echo -e "░░░╚═╝░░░╚══════╝╚═╝░░╚═╝╚═╝░░╚══╝╚═╝╚═╝░░╚═╝"
    echo -e "${RESET}"
    echo -e "${BOLD}${BLUE}Auto roblox clones installer/updater (made by _fizly_)${RESET}\n"
}

print_status_table() {
    local i=1 file stat prog color
    echo -e "${BOLD}${BLUE}PROGRESS STATUS:${RESET}"
    echo -e "┌───────┬──────────────────────┬───────────────┬──────────────┐"
    echo -e "│ ${BOLD}#${RESET}             │ ${BOLD}APK File${RESET}      │  ${BOLD}Status${RESET}       │ ${BOLD}Progress${RESET}    │"
    echo -e "├───────┼──────────────────────┼───────────────┼──────────────┤"
    for file in "${!STATUS[@]}"; do
        stat="${STATUS[$file]}"
        prog="${PROGRESS[$file]:-0%}"
        color="$RESET"
        case "$stat" in
            "PENDING") color="$DIM" ;;
            "DOWNLOADING") color="$YELLOW" ;;
            "DOWNLOADED") color="$BLUE" ;;
            "INSTALLING") color="$YELLOW" ;;
            "INSTALLED") color="$GREEN" ;;
            "FAILED") color="$RED" ;;
        esac
        printf "│ [%d]  │ %-20s │ ${color}%-11s${RESET} │ %-10s  │\n" "$i" "$file" "$stat" "$prog"
        i=$((i+1))
    done
    echo -e "└───────┴──────────────────────┴──────────────┴──────────────┘\n"
}

download_apk() {
    local url="$1"; local dest="$2"; local apk_name="$3"
    STATUS["$apk_name"]="DOWNLOADING"
    PROGRESS["$apk_name"]="0%"
    clear_screen && print_banner && print_status_table
    log "${CYAN}[INFO] Downloading $apk_name from $url"

    if curl -fL -A "Mozilla/5.0 (X11; Linux x86_64)" --retry 3 -o "$dest.part" "$url" --progress-bar; then
        mv "$dest.part" "$dest"
        STATUS["$apk_name"]="DOWNLOADED"
        PROGRESS["$apk_name"]="100%"
        log "${GREEN}[SUCCESS] Downloaded $apk_name"
        return 0
    else
        STATUS["$apk_name"]="FAILED"
        log "${RED}[ERROR] Failed to download $apk_name from $url"
        [[ -f "$dest.part" ]] && rm -f "$dest.part"
        return 1
    fi
}

install_apk() {
    local apk_path="$1"; local apk_name="$2"
    STATUS["$apk_name"]="INSTALLING"
    clear_screen && print_banner && print_status_table
    log "${YELLOW}[INSTALL] Installing/Updating $apk_name"

    if [[ "${apk_name,,}" != *.apk ]]; then
        log "${YELLOW}[SKIP] $apk_name is not an .apk file; download only.${RESET}"
        STATUS["$apk_name"]="DOWNLOADED"
        return 0
    fi

    if command -v pm >/dev/null 2>&1 && pm install -r -d "$apk_path" >> "$LOG_FILE" 2>&1; then
        STATUS["$apk_name"]="INSTALLED"
        log "${GREEN}[SUCCESS] Installed/Updated $apk_name"
        return 0
    else
        if command -v aapt >/dev/null 2>&1; then
            local pkg_name
            pkg_name=$(aapt dump badging "$apk_path" 2>/dev/null | awk -v FS="'" '/package: name=/{print $2}')
            if [[ -n "$pkg_name" ]]; then
                pm uninstall "$pkg_name" >> "$LOG_FILE" 2>&1 || true
                if pm install -d "$apk_path" >> "$LOG_FILE" 2>&1; then
                    STATUS["$apk_name"]="INSTALLED"
                    log "${GREEN}[SUCCESS] Forced reinstall of $apk_name"
                    return 0
                fi
            fi
        fi
        STATUS["$apk_name"]="FAILED"
        log "${RED}[ERROR] Failed to install $apk_name (pm not available or install failed). Check device logs."
        return 1
    fi
}

download_and_install_apks() {
    local -n apks_to_process=$1
    local ok=0 total=${#apks_to_process[@]}

    declare -gA STATUS=()
    declare -gA PROGRESS=()
    for apk in "${apks_to_process[@]}"; do
        STATUS["$apk"]="PENDING"
        PROGRESS["$apk"]="0%"
    done

    for apk_file in "${apks_to_process[@]}"; do
        local url
        if [[ -n "${APK_FULL_URLS[$apk_file]:-}" ]]; then
            url="${APK_FULL_URLS[$apk_file]}"
        else
            url="${BASE_URL%/}/$apk_file"
        fi
        local dest="$APK_DIR/$apk_file"
        if download_apk "$url" "$dest" "$apk_file"; then
            install_apk "$dest" "$apk_file" && ok=$((ok+1))
        fi
        clear_screen && print_banner && print_status_table
        sleep 1
    done

    echo -e "${BOLD}${BLUE}SUMMARY:${RESET} ${GREEN}$ok succeeded${RESET}, ${RED}$((total-ok)) failed${RESET}"
    echo -e "${DIM}Logs saved at $LOG_FILE${RESET}"
}

auto_download_install() {
    log "${BLUE}[OPTION 1] Auto downloading and installing/updating all predefined clones."
    local temp_apk_names=("${APK_NAMES[@]}")
    download_and_install_apks temp_apk_names
}

# -----------------------------
# FIXED: Option 2 uses GitHub API instead of scraping HTML
# -----------------------------
change_url_and_select_download() {
    log "${BLUE}[OPTION 2] Change URL and list assets from the release page."
    echo -e "${YELLOW}Current Base URL for downloads: ${BASE_URL}${RESET}"
    read -r -p "Enter GitHub release TAG URL (e.g. https://github.com/Owner/Repo/releases/tag/v1.0): " NEW_RELEASE_TAG_URL
    NEW_RELEASE_TAG_URL=$(echo "$NEW_RELEASE_TAG_URL" | xargs)

    if [[ -z "$NEW_RELEASE_TAG_URL" ]]; then
        log "${YELLOW}No URL entered. Using existing list.${RESET}"
        return 0
    fi

    # Parse Owner/Repo/Tag from URL
    if [[ "$NEW_RELEASE_TAG_URL" =~ github\.com/([^/]+)/([^/]+)/releases/tag/([^/]+) ]]; then
        owner="${BASH_REMATCH[1]}"
        repo="${BASH_REMATCH[2]}"
        tag="${BASH_REMATCH[3]}"
    else
        log "${RED}[ERROR] Could not parse GitHub release URL. Must look like: https://github.com/Owner/Repo/releases/tag/v1.0${RESET}"
        return 1
    fi

    api_url="https://api.github.com/repos/$owner/$repo/releases/tags/$tag"
    log "${CYAN}[INFO] Fetching release assets from: $api_url${RESET}"
    json="$(curl -sfL -H "Accept: application/vnd.github.v3+json" "$api_url")" || {
        log "${CYAN}[ERROR] Failed to fetch release JSON from GitHub API${RESET}"
        return 1
    }

    mapfile -t asset_urls < <(echo "$json" | grep -oP '"browser_download_url":\s*"\Khttps?://[^"]+')
    mapfile -t asset_names < <(echo "$json" | grep -oP '"name":\s*"\K[^"]+')

    if [[ ${#asset_urls[@]} -eq 0 ]]; then
        log "${CYAN}[ERROR] No assets found in release.${RESET}"
        return 1
    fi

    APK_FULL_URLS=()
    local apks_list=()
    for i in "${!asset_urls[@]}"; do
        fname="${asset_names[$i]}"
        url="${asset_urls[$i]}"
        APK_FULL_URLS["$fname"]="$url"
        apks_list+=("$fname")
    done

    echo -e "\n${BOLD}Available assets found:${RESET}"
    local idx=1
    for fname in "${apks_list[@]}"; do
        echo "  [$idx] $fname"
        idx=$((idx+1))
    done

    echo -e "\nSelect how to pick assets:"
    echo "  1) Manually select by numbers (e.g., 1 3 4)"
    echo "  2) Select by name or comma-separated patterns (e.g., Codex, Codex.5)"
    read -r -p "Choice (1 or 2): " sel_choice
    sel_choice=$(echo "$sel_choice" | xargs)

    local selected_apks=()
    case "$sel_choice" in
        1)
            read -r -p "Enter numbers separated by spaces: " nums
            for n in $nums; do
                if [[ "$n" =~ ^[0-9]+$ ]] && (( n >= 1 && n <= ${#apks_list[@]} )); then
                    selected_apks+=("${apks_list[$((n-1))]}")
                else
                    log "${CYAN}Skipping invalid selection: $n${RESET}"
                fi
            done
            ;;
        2)
            read -r -p "Enter comma-separated names/patterns: " pattern_input
            IFS=',' read -ra patterns <<< "$pattern_input"
            for p in "${patterns[@]}"; do
                p="$(echo "$p" | xargs)"
                for fname in "${apks_list[@]}"; do
                    if [[ "$fname" == *"$p"* ]]; then
                        selected_apks+=("$fname")
                    fi
                done
            done
            ;;
        *)
            log "${CYAN}Invalid selection mode. Returning to menu.${RESET}"
            return 1
            ;;
    esac

    if [[ ${#selected_apks[@]} -eq 0 ]]; then
        log "${CYAN}No assets selected. Returning to main menu.${RESET}"
        return 0
    fi

    log "${BLUE}Proceeding to download ${#selected_apks[@]} asset(s) ...${RESET}"
    download_and_install_apks selected_apks
}

main_menu() {
    while true; do
        clear_screen
        print_banner
        echo -e "${BOLD}Choose an option:${RESET}"
        echo -e "  1) ${CYAN}Start auto download/install/update all roblox clones${RESET}"
        echo -e "  2) ${CYAN}Change URL (list assets from release) and  download/install/update roblox clones${RESET}"
        echo -e "  3) ${CYAN}Exit${RESET}"
        read -r -p "Enter your choice: " choice
        choice=$(echo "$choice" | xargs)

        case "$choice" in
            1)
                auto_download_install
                read -r -p "Press Enter to return to menu..."
                ;;
            2)
                change_url_and_select_download
                read -r -p "Press Enter to return to menu..."
                ;;
            3)
                log "${BLUE}Exiting script. Goodbye!${RESET}"
                echo -e "${BOLD}${BLUE}Exiting. Goodbye!${RESET}"
                safe_exit
                ;;
            *)
                log "${RED}Invalid choice: $choice. Please try again.${RESET}"
                sleep 1
                ;;
        esac
    done
}

main_menu "$@"
